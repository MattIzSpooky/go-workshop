## 8. SQL

Modern (and classic) applications often store data. SQL plays a very big role in data storage.
I will not delve into the history of SQL or why it is being used, but I am extremely confident that most developers
have touched SQL before so that is why I decided to include it.

This example shows how to interact with a database in Go.

For this example we will use [sqlc](https://sqlc.dev/)
Why SQLC? No external libraries, you write SQL. It generates Go code that uses a db driver.
No bloat or extremely slow queries generated by ORMs. 
It can also handle migration tools such as [golang-migrate](https://github.com/golang-migrate/migrate). 
Which is exactly what we will use in this example.

To get started we need the following:
- [sqlc](https://docs.sqlc.dev/en/stable/overview/install.html)
- [golang-migrate](https://github.com/golang-migrate/migrate)

Why do we use migrations? See [this article](https://www.prisma.io/dataguide/types/relational/what-are-database-migrations#what-are-the-advantages-of-migration-tools).

After installing the tools we need some initial configuration that tells sqlc what it's working with.
The biggest requirement is the [sqlc.yaml](./sqlc.yaml) file. This tells sqlc where the SQL files are, what database to use, 
what db driver to use, where to put the generated code, etc.

To generate a set of migration files:
`migrate create -ext sql -dir sql/migrations -seq my_table_here`

This will generate empty migration files.

This example contains a simple application to write and read from a simple database.
The database contains 2 tables, `authors` and `books`.


In this example we have already executed 2 commands.
- `migrate create -ext sql -dir sql/migrations -seq authors_table`
- `migrate create -ext sql -dir sql/migrations -seq books_table`

This generates an "up" and "down" file, because migrations can be rolled back etc.
These files have also been filed with SQL already and can be found [here, in the sql/migrations folder](./sql/migrations).

Now we will show sqlc's magic. SQLC generates code based on written SQL queries.
For this example I have already written some queries, these can be found [here, in the sql/queries folder](./sql/queries).

Last but not least, run the following command to generate the Go code from the SQL queries.
```bash
$ sqlc generate
```

[main.go](./main.go) calls the generated code.

Ideally, you would wrap the generated code with your own layer, such as one introduced with the repository pattern. DTOs are also useful.
This decreases the dependency of your application to the underlying database making it somewhat easier for you to switch to another database if the existing sql files are compatible.

When running this example, you need to do the following first:
1. Run the included [docker compose file](./docker-compose.yml)
2. Run [migrations-up.sh](./migrations-up.sh)
3. Now you can run [main.go](./main.go)